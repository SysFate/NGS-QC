#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Created on 28/01/15

@author: Matthias Blum
"""

import math
import os
import subprocess
import tempfile

from scipy.stats.distributions import poisson


ORGANISMS = {
    'Homo sapiens': ['hg18', 'hg19'],
    'Mus musculus': ['mm8', 'mm9', 'mm10'],
    'Caenorhabditis elegans': ['ce4', 'ce6', 'ce10'],
    'Danio rerio': ['danRer5', 'danRer6', 'danRer7'],
    'Drosophila melanogaster': ['dm3'],
    'Rattus norvegicus': ['rn3', 'rn4', 'rn5'],
    'Arabidopsis thaliana': ['tair8', 'tair9', 'tair10'],
    'Gallus gallus': ['galGal4']
}


def clean(files):
    """

    :param files:
    :return:
    """
    for i, f in enumerate(files):
        if f != files[0]:
            try:
                os.unlink(f)
            except Exception as e:
                print type(e), e, f


def rewrite_genome_file(chrms_lst, genome):
    gfile = os.path.join(os.path.dirname(__file__), 'genomes', genome)
    ginfo = get_genome_info(genome)
    newginfo = {}
    del_gfile = False

    for chrm in chrms_lst:
        if chrm in ginfo:
            newginfo[chrm] = ginfo[chrm]
        elif chrm.lower() in ginfo:
            # "ChrX" found, ref is "chrX"
            newginfo[chrm[0].upper() + chrm[1:]] = ginfo[chrm.lower()]
            del_gfile = True
        elif 'chr' + chrm in ginfo:
            # "X" found, ref is "chrX"
            newginfo[chrm] = ginfo['chr' + chrm]
            del_gfile = True
        else:
            # Other case. Nope. Fuck it.
            pass

    if del_gfile:
        fd, tmpgfile = tempfile.mkstemp()
        os.close(fd)

        with open(tmpgfile, 'w') as fo:
            for k, v in sorted(newginfo.items()):
                fo.write('{0}\t{1}\n'.format(k, v))

        return tmpgfile, del_gfile
    else:
        return gfile, del_gfile


def get_bg(reads, genome_size, **kwargs):
    """
    Compute the background threshold using a Poisson distribution
    :param reads:
    :param genome_size:
    :param kwargs:
    :return:
    """
    bin_size = kwargs.get('binsize', 500)
    conf_int = kwargs.get('confint', 0.999)
    sampling = kwargs.get('sampling', (0.9, 0.7, 0.5))

    sample = list(sampling) + [1]
    subset = {}
    thres = {}
    for s in sample:
        subset[s] = int(s * reads)

    for k, v in subset.items():
        # Lambda = number of reads / (genome size * bins size)
        lambda_l = float(v) / genome_size * bin_size
        d = {}
        d2 = {}

        # Poisson distribution of lambda
        # (1000: it's for handling datasets with a huge number of reads)
        for i in range(1, 1000):
            d[i] = float(poisson.pmf(i, lambda_l))

        for dk, dv in d.items():
            if dv < (1 - conf_int) and dk >= lambda_l:
                d2[dk] = dv

        try:
            min_thre = sorted(d2.items(), key=lambda t: t[1])[-1][0]
        except IndexError as e:
            print lambda_l
            return None
        else:
            thres[k] = min_thre

    return thres


def repgen(bed_file, dest, genome, binsize=500, bgthres=1, numrep=5):
    genome_file = os.path.join(os.path.dirname(__file__), 'genomes', genome)

    if not os.path.isfile(genome_file):
        return None

    cl = [os.path.join(os.path.dirname(__file__), 'utils', 'NGSQC_bed_utils'), 'bin_table_rep', bed_file,
          genome_file, binsize, bgthres, numrep]
    cl = [str(i) for i in cl]

    with open(dest, 'w') as fo:
        pop = subprocess.Popen(cl, stdout=fo, stderr=subprocess.PIPE)
    pop.wait()

    if os.path.isfile(dest) and pop.returncode == 0:
        return dest
    else:
        try:
            os.unlink(dest)
        except:
            pass
        finally:
            return None


def is_binary(input_file):
    """
    Check if a file is a binary file or a text file. Actually, just read the first line.
    :param input_file:
    @return:
    """
    textchars = ''.join(map(chr, [7, 8, 9, 10, 12, 13, 27] + range(0x20, 0x100)))
    is_binary_string = lambda x: bool(x.translate(None, textchars))

    with open(input_file) as f:
        b = is_binary_string(f.read(1024))

    return b


def bamtobed(bam_file, output_dir, bedtools='bedtools'):
    """

    :param bam_file:
    :param output_dir:
    :param bedtools:
    :return:
    """
    bed_file = os.path.join(output_dir, os.path.basename(bam_file)[:-4] + '.bed')

    cl = [bedtools, 'bamtobed', '-i', bam_file]

    with open(bed_file, 'w') as fh, open(os.devnull) as dn:
        pop = subprocess.Popen(cl, stdout=fh, stderr=dn)
        pop.wait()

    if os.path.isfile(bed_file) and pop.returncode == 0:
        return bed_file
    else:
        try:
            os.unlink(bed_file)
        except:
            pass
        finally:
            return None


def gzip(path, output_dir, decompress=False):
    """

    :param path:
    :param output_dir:
    :param decompress:
    :return:
    """
    if decompress:
        cl = ['gzip', '-cd', path]
        dest = os.path.join(output_dir, os.path.basename(path)[:-3])
    else:
        cl = ['gzip', '-c', path]
        dest = os.path.join(output_dir, os.path.basename(path) + '.gz')

    with open(dest, 'w') as fh, open(os.devnull) as dn:
        pop = subprocess.Popen(cl, stdout=fh, stderr=dn)
        pop.wait()

    if os.path.isfile(dest) and pop.returncode == 0:
        return dest
    else:
        try:
            os.unlink(dest)
        except:
            pass
        finally:
            return None


def bed_integrity(bed_file):
    """

    :param bed_file:
    :return:
    """
    cl = [os.path.join(os.path.dirname(__file__), 'utils', 'NGSQC_bed_utils'), 'integrity', bed_file]
    pop = subprocess.Popen(cl, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = pop.communicate()

    if pop.returncode != 0:
        return None, None, None, None, None

    try:
        cols = out.rstrip().split('\t', 6)
        code = int(cols[0])
        reads = int(cols[1])
        no_header = int(cols[4]) == 0
        chrms_lst = sorted(cols[5].split(','))
        last_line = cols[6].rstrip()
    except:
        return None, None, None, None, None
    else:
        return code, reads, no_header, chrms_lst, last_line


def bed_issorted(bed_file, noheader=False):
    """

    :param bed_file:
    :param noheader:
    :return:
    """
    cl = [os.path.join(os.path.dirname(__file__), 'utils', 'NGSQC_bed_utils'), 'issorted', bed_file]

    if noheader:
        cl.append('--no-header')

    pop = subprocess.Popen(cl, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = pop.communicate()

    if pop.returncode != 0:
        return None

    try:
        code = int(out.rstrip())
    except:
        return None
    else:
        return code == 1


def bed_sort(bed_file, output_dir, cores=None, memory=None, sort='sort'):
    """

    :param bed_file:
    :param output_dir:
    :param cores:
    :param memory:
    :param sort:
    :return:
    """
    dest = os.path.join(output_dir, os.path.basename(bed_file)[:-4] + '.sort.bed')

    cl = [sort, '-t\t', '-k1,1', '-k2,2n', '-k6,6']

    if cores:
        cl.append('--parallel={0}'.format(cores))

    if memory:
        cl.append('--buffer-size={0}G'.format(memory))

    cl.append(bed_file)

    with open(dest, 'w') as fh, open(os.devnull) as dn:
        pop = subprocess.Popen(cl, stdout=fh, stderr=dn)
        pop.wait()

    if os.path.isfile(dest) and pop.returncode == 0:
        return dest
    else:
        try:
            os.unlink(dest)
        except:
            pass
        finally:
            return None


def unique_count(bed_file, noheader=False):
    """

    :param bed_file:
    :param noheader:
    :return:
    """
    cl = [os.path.join(os.path.dirname(__file__), 'utils', 'NGSQC_bed_utils'), 'unique', bed_file]

    if noheader:
        cl.append('--no-header')

    pop = subprocess.Popen(cl, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = pop.communicate()

    if pop.returncode != 0:
        return None

    try:
        cols = err.rstrip().split('\t')
        unique_reads = int(cols[1])
    except:
        return None
    else:
        return unique_reads


def unique_filter(bed_file, output_directory, noheader=False):
    """

    :param bed_file:
    :param output_directory:
    :param noheader:
    :return:
    """
    dest = os.path.join(output_directory, os.path.basename(bed_file)[:-4] + '.uniq.bed')

    cl = [os.path.join(os.path.dirname(__file__), 'utils', 'NGSQC_bed_utils'), 'unique', bed_file, '--write']

    if noheader:
        cl.append('--no-header')

    with open(dest, 'w') as fh:
        pop = subprocess.Popen(cl, stdout=fh, stderr=subprocess.PIPE)
        out, err = pop.communicate()

    if pop.returncode == 0 and os.path.isfile(dest):
        return dest
    else:
        try:
            os.unlink(dest)
        except:
            pass
        finally:
            return None


def get_qcvalue(denqc_50, simpqc):
    """
    Compute QC values from denQCis and simQCis
    :param denqc_50:
    :param simpqc
    :return:
    """
    try:
        qc_val = math.log(denqc_50/simpqc, 2)
    except ValueError as e:
        qc_val = None
    finally:
        return qc_val


def get_genome_info(genome, gfile=None):
    info = {}

    if gfile is not None:
        path = gfile
    else:
        path = os.path.join(os.path.dirname(__file__), 'genomes', genome)

    try:
        with open(path) as fh:
            for line in fh:
                chrm, size = line.split('\t', 1)
                info[chrm.strip()] = int(size.strip())
    except:
        return None
    else:
        return info


def num_format(x):
    return str('{:,}'.format(int(x)))
